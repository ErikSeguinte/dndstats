---
output: html_document
always_allow_html: yes
editor_options: 
  chunk_output_type: console
---

```{r setup, include=FALSE}
library(dplyr)
library(magrittr)
library(readr)
library(stringr)
library(ggplot2)
library(cowplot)
library(glue)
library(reshape2)
library(igraph)
library(circlize)
library(patchwork)
library(plotly)
library(shiny)
library(here)
library(ogbox) # github.com/oganm/ogbox
knitr::opts_chunk$set(echo = FALSE, fig.align ='center')

races = c(Aarakocra = 'Aarakocra',
          Aasimar = 'Aasimar',
          Bugbear= 'Bugbear',
          Dragonborn = 'Dragonborn',
          Dwarf = 'Dwarf',
          Elf = '(?<!Half-)Elf',
          Firbolg = 'Firbolg',
          Genasi= 'Genasi',
          Gith = 'Geth',
          Gnome = 'Gnome',
          Goblin='Goblin',
          Goliath = 'Goliath',
          'Half-Elf' = '(Half-Elf)|(^Variant)',
          'Half-Orc' = 'Half-Orc',
          Halfling = 'Halfling',
          Hobgoblin = 'Hobgoblin',
          Human = 'Human',
          Kenku = 'Kenku',
          Kobold = 'Kobold',
          Lizardfolk = 'Lizardfolk',
          Orc = '(?<!Half-)Orc',
          'Yaun-Ti' = 'Serpentblood',
          Tabaxi = 'Tabaxi',
          Tiefling ='Tiefling|Lineage',
          Triton = 'Triton',
          Turtle = 'Turtle|Tortle')

align = list(NG = c('NG',
                    '"Good"',
                    "Neuteral Good",
                    "Neutral Good",
                    "Nuetral Goodt",
                    "Neutral/Good",
                    "Neutral good",
                    'neutral good'),
             CG = c('Chaotic Good',
                    'CG',
                    'Chacotic Good',
                    'Chaotic good',
                    'Good Chaotic',
                    'chaotic good'),
             LG = c('Lawful Good',
                    'LG',
                    'lawful good',
                    'Lawful good'),
             NN = c('Neutral',
                    'n',
                    'N',
                    'True Neutral',
                    'neutral',
                    'TN',
                    'Neutral Neutral',
                    'true neutral',
                    'Neutral neutral'),
             CN = c('Chaotic Neutral',
                    'CN',
                    'chaotic neutral',
                    'Chaotic neutral',
                    'chaotic nuetral',
                    'Chaotic Nuetral',
                    'cn'),
             LN = c('Lawful Neutral',
                    'lawful - neutral',
                    'LN',
                    'Lawful Neutral (good-ish)',
                    'lawful neutral'
             ),
             NE = c('Neutral Evil'),
             LE = c('Lawful Evil'),
             CE = c('CE'))

goodEvil = list(`E` = c('NE','LE','CE'),
                `N` = c('LN','CN','NN'),
                `G` = c('NG','LG','CG'))

lawfulChaotic = list(`C` = c('CN','CG','CE'),
                     `N` = c('NG','NE','NN'),
                     `L` = c('LG','LE','LN'))
getUniqueTable = function(charTable){
    uniqueTable = charTable %>% arrange(desc(level)) %>% filter(!duplicated(paste(name,justClass))) %>% 
        filter(!level > 20)

    
    checkAlignment = function(x,legend){
        x = names(legend)[findInList(x,legend)]
        if(length(x) == 0){
            return('')
        } else{
            return(x)
        }
    }
    
    
    # check if there's anything left
    # uniqueTable$alignment  %>% {.[!. %in% unlist(alignment)]} %>% table %>% sort
    
    uniqueTable %<>% mutate(processedAlignment = alignment %>% purrr::map_chr(checkAlignment,align),
                            good = processedAlignment %>% purrr::map_chr(checkAlignment,goodEvil) %>% 
                                factor(levels = c('E','N','G')),
                            lawful = processedAlignment %>% 
                                purrr::map_chr(checkAlignment,lawfulChaotic) %>% factor(levels = c('C','N','L'))) 
    

    
    uniqueTable %<>% mutate(processedRace = race %>% sapply(function(x){
        out = races %>% sapply(function(y){
            grepl(pattern = y, x,perl = TRUE)
        }) %>% which %>% names
        
        if(length(out) == 0){
            out = ''
        }
        
        return(out)
    }))
    
    # detect non unique characters that multiclassed
    multiClassed = uniqueTable %>% filter(grepl('\\|',justClass))
    singleClassed = uniqueTable %>% filter(!grepl('\\|',justClass))
    
    
    matchingNames = multiClassed$name[multiClassed$name %in% singleClassed$name]%>% na.omit 
    
    isDuplicate = matchingNames %>% sapply(function(nm){
        multiChar = multiClassed %>% filter(name == nm)
        singleChar = singleClassed %>% filter(name == nm)
        
        if(nrow(multiChar) != 1 | nrow(singleChar) != 1){
            warning('Not 1-1 match. Skipping')
            return(FALSE)
        } else{
            isSubset = str_split(multiChar$justClass,pattern = '\\|') %>% {.[[1]]} %>% {singleChar$justClass %in% .}
            isHigherLevel = multiChar$level > singleChar$level
            return(isSubset & isHigherLevel)
        }
    })
    
    singleClassed %<>% filter(!name %in% matchingNames[isDuplicate])
    
    uniqueTable = rbind(singleClassed,multiClassed)
    
    return(list(uniqueTable = uniqueTable,
                singleClassed = singleClassed,
                multiClassed = multiClassed))
}

# load table and get unique characters

charTable = read_tsv(here("docs/charTable.tsv"))
# group levels at common feat acquisition points. sorry fighters and rogues
charTable %<>% mutate(levelGroup = cut(level,
                                       breaks = c(0,3,7,11,15,18,20),
                                       labels  = c('1-3','4-7','8-11','12-15','16-18','19-20')))

# for anyone looking at this and confused by the weird syntax
# see https://stackoverflow.com/questions/1826519/how-to-assign-from-a-function-which-returns-more-than-one-value
list[keepRevised,,] = getUniqueTable(charTable)
charTable$justClass %<>%  gsub(pattern = 'Revised ', replacement = '',x = .)
charTable$class %<>%  gsub(pattern = 'Revised ', replacement = '',x = .)

list[uniqueTable,singleClassed,multiClassed] = getUniqueTable(charTable)


barPalette = c('#7DD4A6','#C15BC5','#D65242','#415455',
               '#D2A75C','#8FD25B','#D15B86','#A5B5BE','#727EC6',
               '#567441','#754334','#5E3A60','#77B0D0',"#CCEBC5",
               "#D9D9D9","#FCCDE5")
```

Table of Contents
=================

   * [Is your D&amp;D character rare? II: Off-brand edition](#is-your-dd-character-rare-ii-off-brand-edition)
      * [Introduction](#introduction)
      * [Is Your D&amp;D Character Rare? II](#is-your-dd-character-rare-ii)
      * [Is your character archetype rare?](#is-your-character-archetype-rare)
      * [Is your alignment rare?](#is-your-alignment-rare)
      * [Are your feat choices rare?](#are-your-feat-choices-rare)
      * [Is your multiclass combination rare?](#is-your-multiclass-combination-rare)
      * [Is power gaming rare?](#is-power-gaming-rare)
      * [Is your game day rare?](#is-your-game-day-rare)
      * [About the data](#about-the-data)
      * [About this document](#about-this-document)
      * [Changelog](#changelog)


# Is your D&D character rare? II: Off-brand edition

*Ogan Mancarci, 28 July 2018*

*Edited: 2 August 2018 (see [changlelog](#changelog))*

## Introduction

About a year ago FiveThirtyEight published a short article called 
["Is Your D&D Character Rare?"](https://fivethirtyeight.com/features/is-your-dd-character-rare/).
It was a product of a deal between Curse and FiveThirtyEight which meant the data
was not available to anyone else. I was a little jealous that I couldn't play with the data and disappointed that they only counted class race combinations and called it a day.

Shortly after, I released a few tools ([1](https://oganm.github.io/printSheetApp/),[2](https://oganm.github.io/5eInteractiveSheet/)) for a popular mobile application ([3](https://play.google.com/store/apps/details?id=com.wgkammerer.testgui.basiccharactersheet.app&hl=en_CA)) which allowed me to collect my users' character data. 

After 3.5 months of data collection
I have a whopping... `r  nrow(uniqueTable)` unique characters in my database that I can play with. Well... I'm not
as popular as DnDBeyond but I don't see anyone else waving around hundreds of character sheets for us to 
data mine, so it'll have to do.

## Is Your D&D Character Rare? II

To start with let's redo the table from FiveThirtyEight. I am not going to pretend
like I have many thousands of samples so instead of per 100,000 this shows class and race combinations per 100
characters. In FiveThirtyEight's table, characters with multiple classes count once for each class. Here I divided multiclassed characters based on the proportion of their class levels. For instance, a character who is a Fighter 5/Rogue 15 will add 0.75 to the rogue count and 0.25 to the fighter count. Homebrew and UA classes are removed.

```{r fiveThirtyEightCopy,fig.width=9}
# the way races are encoded in the app is a little silly. sub-races are 
# not recorded separately. essentially race information is lost other
# than a text field after it's effects are applied during creation.
# The text field is also not too consistent. For instance if you are a 
# variant it'll simply say "Variant" but if you are a variant human
# it'll only say human
# here, I define regex that matches races.
# kind of an overkill as only few races actually required special care

classes = uniqueTable$justClass %>% str_split('\\|') %>% unlist %>% unique
coOccurenceMatrix = matrix(0 , nrow=length(races),ncol = length(classes))
colnames(coOccurenceMatrix) = classes
rownames(coOccurenceMatrix) = names(races)
for (i in seq_along(races)){
    for (j in seq_along(classes)){
        ((uniqueTable$processedRace==names(races)[i]) * {
            classLevel  =str_extract(uniqueTable$class,glue('(?<={classes[j]} )[0-9]+')) %>% {.[is.na(.)] = 0;.} %>% as.integer()
            classLevel/uniqueTable$level
            }) %>% sum -> coOcc
        coOccurenceMatrix[i,j] = coOcc
    }
}

coOccurenceMatrixSubset = coOccurenceMatrix[,!coOccurenceMatrix %>% apply(2,sum) %>% {.<2}]

coOccurenceMatrixSubset = coOccurenceMatrixSubset[!coOccurenceMatrixSubset %>% apply(1,sum) %>% {.<1},]

coOccurenceMatrixSubset = 
    coOccurenceMatrixSubset[coOccurenceMatrixSubset %>% apply(1,sum) %>% order(decreasing = FALSE),
                            coOccurenceMatrixSubset %>% apply(2,sum) %>% order(decreasing = TRUE)]

coOccurenceMatrixSubset = coOccurenceMatrixSubset/(sum(coOccurenceMatrix))* 100


classSums = coOccurenceMatrixSubset %>% apply(2,sum)
raceSums = coOccurenceMatrixSubset %>% apply(1,sum)

coOccurenceMatrixSubset = cbind(coOccurenceMatrixSubset,raceSums)


coOccurenceMatrixSubset = rbind(Total = c(classSums,NA), coOccurenceMatrixSubset)
colnames(coOccurenceMatrixSubset)[ncol(coOccurenceMatrixSubset)] = "Total"

coOccurenceFrame = coOccurenceMatrixSubset %>% melt() 
names(coOccurenceFrame)[1:2] = c('Race','Class')

coOccurenceFrame %<>% mutate(fillCol = value*(Race!='Total' & Class!='Total'))


coOccurenceFrame %>% ggplot(aes(x = Class,y = Race)) +
    geom_tile(aes(fill = fillCol),show.legend = FALSE)+
    scale_fill_continuous(low = 'white',high = '#46A948',na.value = 'white')+
    # viridis::scale_fill_viridis() + 
    geom_text(aes(label = value %>% round(2) %>% format(nsmall=2))) + 
    scale_x_discrete(position='top') + xlab('') + ylab('') + 
    theme(axis.text.x = element_text(angle = 30,vjust = 0.5,hjust = 0)) 

```


```{r fiveThirtyEightCorrMaths,message=FALSE}
fiveThirtyEight = read_tsv('538.tsv') %>% melt()
names(fiveThirtyEight)[2] = 'Class'

fiveThirtyEight %<>% mutate(Class = as.character(Class)) %>%
    arrange(Race,Class) %>% filter(Race !='TOTAL' & Class != 'TOTAL')

coOccurenceFrame %<>% mutate(Race = toupper(Race), Class = toupper(Class)) %>% 
    arrange(Race,Class) %>% 
    filter(Race %in% fiveThirtyEight$Race & Class %in% fiveThirtyEight$Class)

corFrame = data.frame(DnDBeyond = fiveThirtyEight$value/1000, oganm = coOccurenceFrame$value,
           class = coOccurenceFrame$Class,race = coOccurenceFrame$Race)


```

Despite the methodological differences, these results seem to correlate well with DnDBeyond data (Spearman's ρ=`r round(cor(corFrame$DnDBeyond,corFrame$oganm,method = 'spearman'),2)`) even though we seem to disagree on the exact order of popularity. Graph below shows the % occurrence of a class/race combination in DnDBeyond data as presented in FiveThirtyEight and my data.


```{r fiveThirtyEightCorr,message=FALSE,fig.height=3.5,fig.width=3.5}


corFrame %>% ggplot(aes(x = oganm,y = DnDBeyond,text = paste(class, race))) +
    geom_point() + 
    ggtitle("Class-race combination %s at\n DnDBeyond vs oganm's data") ->p

ply = plotly::ggplotly(p) %>%  layout(xaxis=list(fixedrange=TRUE)) %>%
    config(displayModeBar = F) %>% 
    layout(yaxis=list(fixedrange=TRUE))
ply$width = 500
# rmarkdown seems to ignore alignment set using plotly
div(ply,align = 'center')
```

## Is your character archetype rare?

This is a little hard to visualize in a single plot. Alas we are short on space so you're going
to have to mouse over to see the details. Each colored section shows a character archetype's proportion
to the rest of the archetypes for the class. They are ordered from bottom to top in order of 
frequency, so the brown always show the most popular archetype and it goes downhill (but upwards in the plot) from there.

```{r archetypeGraph}
# uniqueTable$justClass
classes = uniqueTable$justClass %>% str_split('\\|') %>% unlist
archetypes = uniqueTable$subclass %>% str_split('\\|') %>% unlist


archeFrame = data.frame(classes,archetypes) %>% filter(archetypes !='') 
classSum = archeFrame$classes %>% table %>% sort(decreasing = TRUE)

archeFrame %<>% group_by(classes,archetypes) %>% summarize(count = n()) %>% 
    arrange(classes,(count)) %>% filter(classes %in% names(which(classSum>2))) %>% 
    ungroup() %>% 
    mutate(archetypes = factor(archetypes,levels = archetypes)) %>% 
    group_by(classes) %>% 
    mutate(ratio = count/sum(count)*100) %>%
    mutate(classArcheID = as.integer(archetypes) - max(as.integer(archetypes)) +1) %>% ungroup() %>% mutate(classArcheID = as.factor(classArcheID)) %>% 
    mutate(`%` = round(ratio))

archeFrame %>% 
    ggplot(aes(x = classes,y = ratio,fill = classArcheID,
               label = archetypes,hede = count,hodo = `%`)) +
    geom_bar(stat='identity') +
     theme(axis.text.x = element_text(angle = 90,vjust = 0.5,hjust = 1 ),
           legend.position = 'none') + 
    scale_fill_manual(values = barPalette) + 
    ggtitle('Archetype choices') + xlab('') + ylab('archetype % within class')->p

ply = ggplotly(p,tooltip = c('label','hodo','hede')) %>% layout(xaxis=list(fixedrange=TRUE)) %>%
    config(displayModeBar = F) %>% 
    layout(yaxis=list(fixedrange=TRUE))
div(ply,align='center')

```

## Is your alignment rare?

Analysis of alignment in this dataset is difficult because unlike most other fields, 
it is not mandatory. It also isn't something you are likely to forget about your
character so there isn't much incentive to fill it in.
Only `r round(sum(!is.na(uniqueTable$alignment))/nrow(uniqueTable)*100)`% of
characters actually filled this field. I know I only filled it myself when testing
my applications. It is entirely possible for the users' choice to fill this box
to introduce a bias so take these results with a grain of salt

Also, since its a free text field, some manual
processing is required to make the most of this information 
(looking at you fellows with the "Awesome" and "Super Good" alignments). But that is
still `r sum(!is.na(uniqueTable$alignment))` characters so there you go:

The plot below shows character counts for each alignment.

```{r alignment, fig.height=2,fig.width=2,fig.align='center'}

alignmentTable = uniqueTable %>% filter(processedAlignment != '')




alignmentCounts = alignmentTable %>% group_by(good,lawful) %>% 
    summarize(Count = n())


alignmentCounts %>% ggplot(aes(x = good,
                               y = lawful,
                               fill = Count,
                               label = Count)) + geom_tile() + 
    scale_fill_continuous(low = 'white',high = '#46A948',na.value = 'white') + 
    geom_text() + 
    xlab('Good/Evil') +
    ylab('Chaotic/Lawful') +
    theme(legend.position = 'none')->p
p
```

In general, lawful characters seem to be out of style these days. Let's see how are 
the tendencies for individual classes. Below graph shows a mean alignment for 
each class. Multiclassed characters' contribution
is calculated as before. You can mouse over to see sample size and mean values.
The numerical values are distributed from 1 to 3. 1 is Chaotic/Evil, 3 is Lawful/Good on 
the corresponding scales.

```{r classAlignment}
uniqueClasses = alignmentTable$justClass %>% str_split('\\|') %>% unlist %>% table %>% {.[.>2]} %>% names

classGood = uniqueClasses %>% sapply(function(x){
    classAlignment = alignmentTable %>% filter(grepl(x,justClass))
    good =classAlignment %$% good
    classProportion = as.integer(stringr::str_extract(classAlignment$class,glue('(?<={x} )[0-9]+')))/classAlignment$level
    weighted.mean(good %>% as.integer,classProportion)
})

classLawful = uniqueClasses %>% sapply(function(x){
    classAlignment = alignmentTable %>% filter(grepl(x,justClass))
    lawful =classAlignment %$% lawful
    classProportion = as.integer(stringr::str_extract(classAlignment$class,glue('(?<={x} )[0-9]+')))/classAlignment$level
    weighted.mean(lawful %>% as.integer,classProportion)
})

classN = uniqueClasses %>% sapply(function(x){
    classAlignment = alignmentTable %>% filter(grepl(x,justClass))
    classProportion = sum(as.integer(stringr::str_extract(classAlignment$class,glue('(?<={x} )[0-9]+')))/classAlignment$level)
    return(classProportion)
})


classAlignments = data.frame(`Good/Evil` = classGood,`Chaotic/Lawful` = classLawful,
                             Class = uniqueClasses,N = classN,
                             check.names = FALSE) 

classAlignments %>% ggplot(aes(x = `Good/Evil`,y = `Chaotic/Lawful`, color = Class,hede = N)) + geom_point() +  
    scale_x_continuous(breaks = c(1,2,3),
                       labels = c('E','N','G'),limits = c(1,3)) + 
    scale_y_continuous(breaks = c(1,2,3),
                       labels = c('C','N','L'), limits = c(1,3))+
    xlab('Good/Evil') +
    ylab('Chaotic/Lawful') + 
    scale_color_manual(values = barPalette) ->p

ply = plotly::ggplotly(p) %>%  layout(xaxis=list(fixedrange=TRUE)) %>%
    config(displayModeBar = F) %>% 
    layout(yaxis=list(fixedrange=TRUE))
ply$width = 400
ply$height = 300
# rmarkdown seems to ignore alignment set using plotly
div(ply,align = 'center')

```

Darn! Most of the space in this graph is wasted. Even good old paladin has a 
chaotic tendency. Seems like 5e really helped players to break tradition. Meanwhile, Warlock is predictably the evilest class.

We can also
do the same to backgrounds. Since they probably explain more than a character's 
back story than a class does we might get more information.


```{r backGroundAlignment}

getMeanAlignments = function(table, property, minRepresentation = 3){
    uniqueThing = table[[property]] %>% table %>% {.[.>minRepresentation]} %>% names
    goodThing = uniqueThing %>% sapply(function(x){
        thingAlignment = table[table[[property]] %in%  x,]
        good =thingAlignment %$% good
        mean(good %>% as.integer)
    })
    lawfulThing = uniqueThing %>%  sapply(function(x){
        thingAlignment = table[table[[property]] %in%  x,]
        lawful =thingAlignment %$% lawful
        mean(lawful %>% as.integer)
    })
    
    thingCount = uniqueThing %>% sapply(function(x){
        table[table[[property]] == x,] %>% nrow
    })
    
    thingAligment = data.frame(`Good/Evil` = goodThing,`Chaotic/Lawful` = lawfulThing,
                             thing = uniqueThing,N = thingCount,
                             check.names = FALSE) 
    names(thingAligment)[3] = property
    return(thingAligment)
}

backgroundAlignment = getMeanAlignments(alignmentTable,property = 'background')

names(backgroundAlignment)[3] = 'Background'

backgroundAlignment %>% ggplot(aes(x = `Good/Evil`,y = `Chaotic/Lawful`, color = Background,hede = N)) + geom_point() +  
    scale_x_continuous(breaks = c(1,2,3),
                       labels = c('E','N','G'),limits = c(1,3)) + 
    scale_y_continuous(breaks = c(1,2,3),
                       labels = c('C','N','L'), limits = c(1,3))+
    xlab('Good/Evil') +
    ylab('Chaotic/Lawful') ->p# + 
    # scale_color_manual(values = barPalette) 

ply = plotly::ggplotly(p) %>%  layout(xaxis=list(fixedrange=TRUE)) %>%
    config(displayModeBar = F) %>% 
    layout(yaxis=list(fixedrange=TRUE))
ply$width = 550
ply$height = 300
# rmarkdown seems to ignore alignment set using plotly
div(ply,align = 'center')

```

This looks better. On extremes we have Knights who tend to be lawful, Folk Heroes
and Hermits on the good, Bounty Hunters, Charlatans, Urchins on chaotic and Criminals
as the only background left of Neutral on the Good/Evil line.

Obviously next logical step is racial profiling.

```{r raceAlignment}

raceAlignment = getMeanAlignments(alignmentTable,property = 'processedRace')


names(raceAlignment)[3] = 'Race'

raceAlignment %<>% filter(Race !='')


raceAlignment %>% ggplot(aes(x = `Good/Evil`,y = `Chaotic/Lawful`, color = Race,hede = N)) +
    geom_point() +  
    scale_x_continuous(breaks = c(1,2,3),
                       labels = c('E','N','G'),limits = c(1,3)) + 
    scale_y_continuous(breaks = c(1,2,3),
                       labels = c('C','N','L'), limits = c(1,3))+
    xlab('Good/Evil') +
    ylab('Chaotic/Lawful') +
    scale_color_manual(values = barPalette) ->p# + 
    # scale_color_manual(values = barPalette) 

ply = plotly::ggplotly(p) %>%  layout(xaxis=list(fixedrange=TRUE)) %>%
    config(displayModeBar = F) %>% 
    layout(yaxis=list(fixedrange=TRUE))
ply$width = 500
ply$height = 300
# rmarkdown seems to ignore alignment set using plotly
div(ply,align = 'center')

```

Take that racism! Half-orcs tend to be nicer characters than humans (Disclaimer: Like most, if not all of the one to one comparisons you can make here, difference between Half-Orc and Human "goodness" is not statistically significant, p = `r alignmentTable %>% filter(processedRace %in% c('Human','Half-Orc')) %>% mutate(good = as.integer(good))  %>% lm(good~processedRace,data=.) %>% summary %$% coefficients %>% {.[2,4]} %>% round(digits = 2)`). Alas, Tieflings
are as close to Chaotic Stupid as they are stereotyped as.

<!-- ## Are your skills rare? -->

<!-- Skills are this is where I get bored -->

<!-- ```{r skills} -->
<!-- uniqueTable$skills %>% str_split('\\|') %>% unlist %>% table %>% sort -->
<!-- ``` -->

## Are your feat choices rare?

Jeremy Crawford once [tweeted](https://twitter.com/jeremyecrawford/status/969020122177331200?lang=en)

> Another piece of D&D data: a majority of D&D characters don't use feats. Many players love the customization possible with feats, but a larger group of players is happy to make characters without feats. Feats are, therefore, not a driving force behind many players' choices. 

We can see whether or not our data agrees. On a surface look `r round(sum(!is.na(uniqueTable$feats))/nrow(uniqueTable)*100)`% of all characters
have at least one feat. However, this is partially caused by  the fact that a significant portion (`r round(sum(uniqueTable$level %in%  c(1,2,3))/nrow(uniqueTable)*100)`%) 
of our characters are between levels 1-3 and unless they are variant humans, they cannot have feats. We can see that by higher levels, feat adoption rates increase significantly, suggesting that once given the opportunity, players are likely to pick a feat.


```{r featProportions,fig.height=4.3}
uniqueTable %>% 
    filter(!is.na(levelGroup)) %>% 
    group_by(levelGroup) %>% 
    mutate(levelGroup2 = paste0(levelGroup,'\n(',n(),' chars)')) %>% 
    ungroup() %>% 
    arrange(levelGroup) %>% 
    mutate(levelGroup2 = factor(levelGroup2, levels = unique(levelGroup2))) %>% 
    group_by(levelGroup2) %>% 
    summarise(featPopularity = sum(!is.na(feats))/n()*100) %>%
    ggplot(aes(x = levelGroup2,y = featPopularity)) +
    geom_text(aes(label = paste(round(featPopularity),'%')),vjust=-0.25) + 
    geom_bar(stat = 'identity') +
    ylab('% with at least one feat') + xlab('Level Interval') + 
    ggtitle('Feat adoption by character levels')

```

It can be postulated players spend most of their time between levels 4-15. `r uniqueTable %>% filter(as.integer(levelGroup) %in% c(2,3,4)) %>% {round(sum(!is.na(.$feats))/nrow(.)*100)}`% of all characters
in this range has at least one feat. As I later discovered, this also somewhat correlates with the
[data in DnDBeyond](https://twitter.com/BadEyeAdam/status/969435420676231169) though the percentages
here are higher overall.


Next logical step is to examine which classes picks which feats, and which feats 
are the most popular. The graph below shows which feat is selected the most and by which 
class. Multiclassed characters are merged into their own category to reduce clutter.
Any feat that is selected only once is removed. Again, mouse over the bars to see details.

```{r featBar}
featedChars = uniqueTable %>%
    filter(!is.na(feats)) %>%
    mutate(justClass = {justClass[grepl('\\|',justClass)] = 'Multiclassed';justClass}) %>% 
    filter(justClass %in% names(which(table(justClass)>1)))
class = featedChars$justClass
feats = featedChars$feats

uniqueFeats = feats %>% str_split('\\|') %>% unlist %>% unique %>% na.omit()

featPicks =  feats %>% str_split('\\|') 

names(featPicks) = class

featFrame = 
    featPicks %>% melt %>% {names(.) = c('Feat','Class');.} %>%
    mutate(Feat = factor(Feat,levels = names(sort(table(Feat),decreasing = TRUE)))) %>% 
    filter(Feat %in% names(which(table(Feat)>1))) %>% group_by(Feat,Class) %>% summarize(Count = n())


featFrame %>% 
    ggplot(aes(x = Feat,y = Count, fill = Class)) +
    geom_bar(stat = 'identity') +
    xlab('') + 
    theme(axis.text.x = element_text(angle = 90,vjust = 0.5,hjust = 1 )) + 
    scale_fill_manual(values = barPalette)+
    ggtitle('Feat popularity and class prefence')->p

ply = plotly::ggplotly(p) %>% config(displayModeBar = F) %>% layout(xaxis=list(fixedrange=TRUE)) %>% layout(yaxis=list(fixedrange=TRUE))

ply$height = 500

div(ply,align='center')
# version of this code that splits multiclasses into components. results
# in an ugly graph
# singleClassed %>% filter(!is.na(feats))

# 
# feats = uniqueTable$feats %>% str_split('\\|') %>% unlist %>% na.omit%>%unique
# 
# classes = uniqueTable$justClass %>% str_split('\\|') %>% unlist %>% unique
# featCoOccurence = matrix(0,nrow = length(feats),ncol = length(classes))
# 
# for (i in seq_along(feats)){
#     for (j in seq_along(classes)){
#         ((grepl(feats[i],uniqueTable$feats,perl= TRUE)) * {
#             classLevel  =str_extract(uniqueTable$class,glue('(?<={classes[j]} )[0-9]+')) %>% {.[is.na(.)] = 0;.} %>% as.integer()
#             classLevel/uniqueTable$level
#             }) %>% sum -> coOcc
#         featCoOccurence[i,j] = coOcc
#     }
# }
# 
# colnames(featCoOccurence) = classes
# rownames(featCoOccurence) = feats
# 
# featCoOccurence = featCoOccurence[,!featCoOccurence %>% apply(2,sum) %>% {.<2}]
# featCoOccurence = featCoOccurence[!featCoOccurence %>% apply(1,sum) %>% {.<1},]
# 
# featFrame = featCoOccurence %>% melt %>% filter(value!=0) %>% {names(.)=c('Feat','Class','Count');.}
# popFeat = featFrame %>% group_by(Feat) %>% summarize(total = sum(Count)) %>% arrange(desc(total)) %>% filter(total>1)
# featFrame %<>% 
#     filter(Feat %in% popFeat$Feat) %>%
#     mutate(Feat = factor(Feat,levels = popFeat$Feat),
#            Class = factor(Class, levels = sort(as.character(unique(Class)))))
# 
# 
# featFrame %>% 
#     ggplot(aes(x = Feat,y = Count, fill = Class)) + geom_bar(stat = 'identity') +
#     xlab('') + 
#      theme(axis.text.x = element_text(angle = 90,vjust = 0.5,hjust = 1 )) + 
#     scale_fill_manual(values = c('#7DD4A6','#C15BC5','#D65242','#415455','#D2A75C','#8FD25B',
#                                  '#D15B86','#A5B5BE','#727EC6','#567441','#754334','#5E3A60'))+
#     ggtitle('Feat popularity and class prefence')->p
# 
# ply = plotly::ggplotly(p)
# 
# ply$height = 500
# 
# div(ply,align='center')

```

It is surprising that Elven Accuracy, a feat that is added in a supplement and restricted to elves, is as 
popular as many core book feats that are known to be highly effective. `r uniqueTable %>% filter(grepl('elf|Variant',race,ignore.case = TRUE)) %$% feats %>% {grepl('Elven A',.)} %>% {sum(.)/length(.)*100} %>% round`% of all elves and half-elves have this feat. Its appeal to both
ranged weapon attackers and casters seems to make it a good choice for elves from many walks
of life. Another interesting bit 
is that the Magic Initiate feat seems be very popular amongst classes with spellcasting ability. I was
always under the impression that Magic Initiate's main use case would be to add some magic to a mundane
class.

We can also look into how feats synergize with each other. The network below shows how often feats 
are selected together. Unique connections are removed. Node sizes represent how many times a feat appeared together with another feat. The thickness of the lines between the nodes are determined
by the number of characters both feats appear in.

```{r featNetwork}
featCoOccurence = uniqueTable %>% filter(grepl("\\|",feats)) %$% feats
uniqueFeats = featCoOccurence %>% strsplit('\\|') %>% unlist %>% table %>% sort(decreasing = TRUE) %>% 
    {.[.>0]}%>% names
adjMatrix = matrix(0,nrow= length(uniqueFeats),ncol = length(uniqueFeats))


for (i in seq_along(uniqueFeats)){
    for(j in seq_along(uniqueFeats)){
        if(i !=j){
            adjMatrix[i,j] = sum(grepl(x = featCoOccurence,pattern = uniqueFeats[i]) &  grepl(x = featCoOccurence,pattern = uniqueFeats[j]))
        }
    }
}

rownames(adjMatrix) = uniqueFeats
colnames(adjMatrix) = uniqueFeats

threshold = 1
adjMatrix = adjMatrix-threshold
adjMatrix[adjMatrix < 1] = 0
zeroFilter = adjMatrix %>% apply(1,sum) %>% {.!=0}
adjMatrix = adjMatrix[zeroFilter,zeroFilter]


network=graph_from_adjacency_matrix( adjMatrix, weighted=T, mode="undirected", diag=F)
E(network)$width <- E(network)$weight*2.5

maxWeight = E(network)$weight %>% max
maxStrength = strength(network) %>% max
par(mar=c(0,0,1,0))

set.seed(9)
plot(network,
     vertex.frame.color="white",
     vertex.label.color="black",
     vertex.size = strength(network)*2.5,
     main = 'Feat synergy network',
     asp = 1)
```

Before I say anything, I have to declare the connections in this graph aren't particularly
strong. There are
too many feats and I have too few characters for high number of feats to appear together.
The strongest link in this graph is based on `r max(adjMatrix)+1` observations.

Yet, as it stands, the connections seem quite intuitive, so we are probably not staring at noise here.
Robustness of elven accuracy is visible in this graph as it is both selected by 
characters trying to optimize their ranged and spell attacks.
Crossbow Expert-Sharpshooter is known to be an effective combination to boost damage.
Sentinel-Polearm Master is amazing for battlefield control.

## Is your multiclass combination rare?

Since our dataset includes multiclassed characters, we can see which classed tend to appear
together. Note that our sample size much smaller here (`r nrow(multiClassed)` characters). Node sizes in the 
network below show how many times a class appeared in all multiclassed characters. The thickness of the lines between the nodes
are determined by the number of characters both classes appear in. For instance, we see that most rangers
multiclass with rogues, while most rogues multiclass with fighters.

```{r multiClassingNetwork}

coOccurence = multiClassed$justClass
# in case I need them ordered
uniqueClasses =   coOccurence %>% 
    strsplit('\\|') %>%
    unlist %>% 
    table %>% 
    sort(decreasing = TRUE) %>%
    names
uniqueClasses = uniqueClasses[!uniqueClasses %in% 'Artificer']

adjMatrix = matrix(0,nrow= length(uniqueClasses),ncol = length(uniqueClasses))

for (i in seq_along(uniqueClasses)){
    for(j in seq_along(uniqueClasses)){
        if(i !=j){
            adjMatrix[i,j] = sum(grepl(x = coOccurence,pattern = uniqueClasses[i]) &  grepl(x = coOccurence,pattern = uniqueClasses[j]))
        }
    }
}
rownames(adjMatrix) = uniqueClasses
colnames(adjMatrix) = uniqueClasses
network=graph_from_adjacency_matrix( adjMatrix, weighted=T, mode="undirected", diag=F)
E(network)$width <- E(network)$weight

maxWeight = E(network)$weight %>% max
maxStrength = strength(network) %>% max
par(mar=c(0,0,1,0))

plot(network,layout = layout_in_circle,
     vertex.frame.color="white",
     vertex.label.color="black",
     vertex.size = strength(network),
     main = 'Multiclassing network',
     asp = 1
     )


```

While this network is good to show which classes tend to be chosen together, it doesn't
give much information about how classes are distributed. In the below graph we look at
what is ratio of class levels in individual characters. A Fighter 5/Rogue 15 would appear
as a 25% data point in the Fighter column and 75% in the Rogue column. This will give
us information about which classes are dipped in and which ones are used as the main class.

```{r multiClassingProportions}

multiClassProportion = lapply(uniqueClasses, function(x){
    classSubset = multiClassed %>% filter(grepl(x,justClass))
    
    classLevel = classSubset$class %>% 
        str_extract(glue('{x} [0-9]+')) %>% 
        str_extract('[0-9]+') %>%
        as.integer
    
    classLevel/classSubset$level
    
})

multiClassTotalLevel =  lapply(uniqueClasses, function(x){
    classSubset = multiClassed %>% 
        filter(grepl(x,justClass))
    totalLevel = classSubset$level

})

multiClassChar = lapply(uniqueClasses, function(x){
    classSubset = multiClassed %>% 
        filter(grepl(x,justClass))
    classInfo = classSubset$class

})

names(multiClassProportion) = uniqueClasses
names(multiClassTotalLevel) = uniqueClasses

multiClassProportion %<>%
    melt
order = multiClassProportion %>% 
    group_by(L1) %>% 
    summarise(mean = mean(value)) %>% 
    arrange(desc(mean)) %$% L1

multiClassProportion$L1 %<>% factor(levels = order)
multiClassTotalLevel %<>% melt
multiClassChar %<>% melt
multiClassProportion = cbind(multiClassProportion,multiClassTotalLevel$value,multiClassChar$value)

names(multiClassProportion) = c('ClassProp','Class','Level','Char')


multiClassProportion %<>% mutate(ClassProp = round(ClassProp * 100,digits = 2))

multiClassProportion %>%
    ggplot(aes(x = Class, y = ClassProp, label = Char)) + 
   geom_violin(color = "#C4C4C4", fill = "#C4C4C4") +
    geom_jitter(alpha = .5,width = 0.1) +
    theme(axis.text.x = element_text(angle = 90,vjust = 0.5,hjust = 1 )) + 
    ylab('% of character level') +
    xlab('') ->p

ply = ggplotly(p) %>%  layout(xaxis=list(fixedrange=TRUE)) %>%
    config(displayModeBar = F) %>% 
    layout(yaxis=list(fixedrange=TRUE))
ply$width = 600
ply$x$data[[2]]$text = multiClassProportion$Char
ply$x$data[[1]]$hoverinfo = 'none'
div(ply,align = 'center')

```

While there is a high amount of variation in the data, some conventional wisdom 
pops up through the means. Warlock is famous for its dipping potential and a Cleric
level synergizes nicely with many other class features. I am a proud player of a Cleric
dipped Fighter myself. I would avoid reading too much into this though. The variance
is too high and sample size is too low to make reliable inferences.

And finally let's see which classes tend to appear in multiclassed builds compared
to single classed ones

```{r mutliVsSingle}

totalClass = uniqueClasses %>% sapply(function(x){grepl(x,uniqueTable$justClass) %>% sum})
multiClass = uniqueClasses %>% sapply(function(x){grepl(x,multiClassed$justClass) %>% sum})

multiProps = sort(multiClass/totalClass,decreasing = TRUE)

data.frame(Class = factor(names(multiProps),levels = names(multiProps)),Prop = multiProps*100) %>% 
    ggplot(aes(x = Class, y= Prop)) + 
     geom_bar(stat = 'identity') +
    xlab('') + 
        geom_text(aes(label = paste(round(Prop),'%')),vjust=-0.25) + 
     theme(axis.text.x = element_text(angle = 90,vjust = 0.5,hjust = 1 ))  + ylab('% in multiclassed build')
```


## Is power gaming rare?

```{r multiClassingAndFeats}
highLevel = uniqueTable %>% filter(levelGroup %>% as.integer %>% {.>1})
HLmultiClassed = highLevel %>% filter(grepl('\\|',justClass))
HLsingleClassed = highLevel %>% filter(!grepl('\\|',justClass))

singleClassedFeaters = sum(!is.na(HLsingleClassed$feats))

multiClassedFeaters = sum(!is.na(HLmultiClassed$feats))
pVal = phyper(multiClassedFeaters,
              multiClassedFeaters + singleClassedFeaters,
              sum(is.na(uniqueTable$feats)),
              nrow(multiClassed), lower.tail = FALSE, log.p = FALSE)
```

Ok that title is a stretch, but we have a format to stick to.

Both multiclassing and picking feats are somewhat advanced character building rules.
While making the character building process complicated, they can be used to create frighteningly 
affective combinations (or get stuck waiting till the end of the campaign till their build gets
everything they want). Intuitively, it wouldn't be surprising to see that multiclassers are more likely
to get feats to optimize their builds. Indeed, we see that `r round(multiClassedFeaters/nrow(HLmultiClassed)*100)`% 
of  multiclassed characters above level 3 chose to get a feat as opposed to 
`r round(singleClassedFeaters/nrow(HLsingleClassed)*100)`% of single classed counterparts.
A modest yet statistically significant difference (p=`r format.pval(pVal,digits = 2)`).

## Is your game day rare?

My applications are they are purely utilitarian. One gives you
a character sheet, the other is an interactive character sheet that automates your dice roll.
It is somewhat reasonable to think that most people would be using them shortly before or during a game. Graphs below
how many characters were created in each day of the week and below that there's a punch card that 
shows individual hours. 



```{r gameDay,fig.height=8}
reliableDateTable = uniqueTable %>% filter(as.Date(date) >  as.Date('2018-04-16'))

days = reliableDateTable$ date %>% weekdays()
hours = as.POSIXlt( reliableDateTable$date)$hour

time = data.frame(days = factor(days, levels = c('Monday','Tuesday','Wednesday','Thursday','Friday','Saturday','Sunday')), hours = hours)


time %>% group_by(days,hours) %>% summarise(Characters = n()) %>%
    ggplot(aes(x = days,y = hours,size = Characters)) + geom_point() +
    theme(axis.text.x = element_text(angle = 90,vjust = 0.5,hjust = 1 ),
          plot.margin = unit(c(0,0,0,0),'cm')) +
    xlab('') +
    ylab('Hour of Day') -> plot1

time %>% group_by(days) %>% summarise(Characters = n()) %>% 
    ggplot(aes(x = days,y = Characters)) + geom_bar(stat ='identity') + 
    theme(axis.text.x = element_blank(),
          axis.ticks.x = element_blank(),
          plot.margin = unit(c(0,0,0,0),'cm'))+
    xlab('') + ggtitle('Time of character submission') -> plot2

plot2/plot1 + plot_layout(ncol = 1, heights = c(3,5))

```

Frankly not much to be said here. Most popular days of the week are obviously weekends and Friday. DnD 
takes time. More work = less DnD.
Hours of day are somewhat unreliable as I didn't correct for user time zones. US alone,  which seems to be 
where most my users are coming from, can
have 3 hours of difference. I could use IPs and detect locations to fix times but not 
going into that rabbit hole... How long before the game a player may want their character 
sheet is also a great source of variability. I mostly did this because I like punch cards...

## About the data

Unique characters are acquired by grouping the characters that share the same name and class
and picking the higher level version. This could have merged independent characters with tropey names
like Grognak the Barbarian of Drizzt the Ranger but manual examination of the data showed no cases of characters
who appear to be made by different people but still has the same name and class. 

If a multiclassed character shares name with a single
classed character, I assume they are duplicates if the single classed character is lower level and
its class matches with one of the classes of the multiclassed character. 

Any character above level 20 (there were `r sum(charTable$level > 20)`) were removed. 

`r sum(grepl('Revised',keepRevised$class,ignore.case = TRUE))` Revised Rangers were merged back into
the ranger class. 

Most percentages are rounded to the nearest integer.

As all data, this data comes with caveats. It is a subset of all DnD players who are using a
particular mobile application who also know about and use my applications and consented
to let me to keep their character sheets. I don't have reason
to think that these would be enriching certain character building choices but it's
something to keep in mind.


```{r statistics}
fighterCount = grepl('Fighter',uniqueTable$class) %>% sum
battleMasterCount = uniqueTable$subclass %>% str_split('\\|') %>% unlist %>% {. %in% 'Battle Master'} %>% sum
battleMasterPercent = battleMasterCount/fighterCount
bmConfInf = sqrt(battleMasterPercent*(1-battleMasterPercent)/fighterCount) * 1.96


championCount = uniqueTable$subclass %>% str_split('\\|') %>% unlist %>% {. %in% 'Champion'} %>% sum
championPercent = championCount/fighterCount
cmConfInf= sqrt(championPercent*(1-championPercent)/fighterCount) * 1.96


```
In most parts of this document no information is provided about whether or not the differences
are actually statistacilly significant. Sorry about that. Didn't want to fill this place with
too much math. For instance we can see that we have
`r battleMasterCount` battle masters
vs `r championCount` champions. This is not a statistically significant difference based on our sample size
so we cannot state with high confidence that the battle master is the more popular choice. 

If you are interested in significance of any of these measures, you can take a peak at this [article](https://en.wikipedia.org/wiki/Margin_of_error) on wikipedia where formulas needed are explained.
For some of these at least you should be able to get the information you need from the article.

If you have any questions, you can [mail me](mailto:ogan.mancarci@gmail.com). Mention "dndstats"
somewhere in the
text so you won't be sent to spam.

## About this document

The text of this document is licensed under [CC BY 4.0](https://creativecommons.org/licenses/by/4.0/) license

[Here](https://github.com/oganm/DnDStatistics/blob/master/docs/index.Rmd)'s its source code. It's not pretty. 

The code blocks within the source code is licensed under [MIT license](https://opensource.org/licenses/MIT).

## Changelog

**28 July 2018:** 

* Initial release

**2 August 2018:** 

* License information added. 
* A forgotten word added.
* Data from 40 additional characters incorporated. No significant changes observed.
* Claim about increased decency of Half-Orcs softened
* Changelog added

<!-- # Supplementary figures -->

<!-- I have some more free time now so I thought I could look at a few things that I -->
<!-- missed the first time -->

<!-- ## Supplementary info - Are your skills rare -->

<!-- ## Supplementary info - Are your spells rare -->


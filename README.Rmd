---
output: github_document
always_allow_html: yes
editor_options: 
  chunk_output_type: console
---

```{r setup, include=FALSE}
library(dplyr)
library(magrittr)
library(readr)
library(stringr)
library(ggplot2)
library(cowplot)
library(glue)
library(reshape2)
library(igraph)
library(circlize)
library(patchwork)
library(ogbox)
knitr::opts_chunk$set(echo = FALSE, fig.align ='center')

getUniqueTable = function(charTable){
    uniqueTable = charTable %>% arrange(desc(level)) %>% filter(!duplicated(paste(name,justClass))) %>% 
        filter(!level > 20)
    # detect non unique characters that multiclassed
    # this is somewhat of a heuristic
    multiClassed = uniqueTable %>% filter(grepl('\\|',justClass))
    singleClassed = uniqueTable %>% filter(!grepl('\\|',justClass))
    
    
    matchingNames = multiClassed$name[multiClassed$name %in% singleClassed$name]%>% na.omit 
    
    isDuplicate = matchingNames %>% sapply(function(nm){
        multiChar = multiClassed %>% filter(name == nm)
        singleChar = singleClassed %>% filter(name == nm)
        
        if(nrow(multiChar) != 1 | nrow(singleChar) != 1){
            warning('Not 1-1 match. Skipping')
            return(FALSE)
        } else{
            isSubset = str_split(multiChar$justClass,pattern = '\\|') %>% {.[[1]]} %>% {singleChar$justClass %in% .}
            isHigherLevel = multiChar$level > singleChar$level
            return(isSubset & isHigherLevel)
        }
    })
    
    singleClassed %<>% filter(!name %in% matchingNames[isDuplicate])
    
    uniqueTable = rbind(singleClassed,multiClassed)
    
    return(list(uniqueTable = uniqueTable,
                singleClassed = singleClassed,
                multiClassed = multiClassed))
}

# load table and get unique characters

charTable = read_tsv("charTable.tsv")

charTable %<>% mutate(levelGroup = cut(level,
                                      breaks = c(0,3,7,11,15,18,20),
                                      labels  = c('1-3','4-7','8-11','12-15','16-18','19-20')))

list[keepRevised,,] = getUniqueTable(charTable)
charTable$justClass %<>%  gsub(pattern = 'Revised ', replacement = '',x = .)
charTable$class %<>%  gsub(pattern = 'Revised ', replacement = '',x = .)

list[uniqueTable,singleClassed,multiClassed] = getUniqueTable(charTable)


```

# DnD character statistics

## Introduction

About a year ago FiveThirtyEight published a short article called 
["Is Your D&D Character Rare?"](https://fivethirtyeight.com/features/is-your-dd-character-rare/).
It was a product of a deal between Curse and FiveThirtyEight which meant the data
was not available to anyone else. I was a little jealous that I couldn't play with the data and disappointed that they only counted class race combinations and called it a day.

Shortly after that I released a few add ons ([1](https://oganm.github.io/printSheetApp/),[2](https://oganm.github.io/5eInteractiveSheet/)) for a [popular mobile application](https://play.google.com/store/apps/details?id=com.wgkammerer.testgui.basiccharactersheet.app&hl=en_CA) which allowed me to collect the users' character sheets. 

After 3.5 months of data collection
I have a whopping... `r  nrow(uniqueTable)` unique characters in my database that I can play with. Well... I'm not
as popular as DnDBeyond but I don't see anyone else waving around thousands of character sheets for us to 
data mine so it'll have to do.

## Is Your D&D Character Rare II?

To start with let's repeat the original analysis from FiveThirtyEight. I am not going to pretend
like I have many thousands of samples so instead of per 100,000 this shows class and race combinations per 100
characters. You'll also notice that there are decimal points. In FiveThirtyEight's table, characters with multiple classes count once for each class. Here I divided multiclassed characters based on the proportion of their class levels. For instance a character who is a Fighter 5/Rogue 15 will add 0.75 to the rogue count and 0.25 to the fighter count. It also includes all races. Homebrew and UA classes are removed.

```{r fiveThirtyEightCopy,fig.width=9}
# the way races are encoded in the app is a little silly. sub-races are 
# not recorded separately. essentially race information is lost other
# than a text field after it's effects are applied during creation
# here, I define regex that matches races.
# kind of an overkill as only few races actually required special care
races  = uniqueTable$race %>% unique
races = c(Aarakocra = 'Aarakocra',
          Aasimar = 'Aasimar',
          Bugbear= 'Bugbear',
          Dragonborn = 'Dragonborn',
          Dwarf = 'Dwarf',
          Elf = '(?<!Half-)Elf',
          Firbolg = 'Firbolg',
          Genasi= 'Genasi',
          Gith = 'Geth',
          Gnome = 'Gnome',
          Goblin='Goblin',
          Goliath = 'Goliath',
          'Half-Elf' = '(Half-Elf)|(Variant)',
          'Half-Orc' = 'Half-Orc',
          Halfling = 'Halfling',
          Hobgoblin = 'Hobgoblin',
          Human = 'Human',
          Kenku = 'Kenku',
          Kobold = 'Kobold',
          Lizardfolk = 'Lizardfolk',
          Orc = '(?<!Half-)Orc',
          'Yaun-Ti' = 'Serpentblood',
          Tabaxi = 'Tabaxi',
          Tiefling ='Tiefling|Lineage',
          Triton = 'Triton',
          Turtle = 'Turtle|Tortle')



classes = uniqueTable$justClass %>% str_split('\\|') %>% unlist %>% unique
coOccurenceMatrix = matrix(0 , nrow=length(races),ncol = length(classes))
colnames(coOccurenceMatrix) = classes
rownames(coOccurenceMatrix) = names(races)
for (i in seq_along(races)){
    for (j in seq_along(classes)){
        ((grepl(races[i],uniqueTable$race,perl= TRUE)) * {
            classLevel  =str_extract(uniqueTable$class,glue('(?<={classes[j]} )[0-9]+')) %>% {.[is.na(.)] = 0;.} %>% as.integer()
            classLevel/uniqueTable$level
            }) %>% sum -> coOcc
        coOccurenceMatrix[i,j] = coOcc
    }
}

coOccurenceMatrixSubset = coOccurenceMatrix[,!coOccurenceMatrix %>% apply(2,sum) %>% {.<2}]

coOccurenceMatrixSubset = coOccurenceMatrixSubset[!coOccurenceMatrixSubset %>% apply(1,sum) %>% {.<1},]

coOccurenceMatrixSubset = 
    coOccurenceMatrixSubset[coOccurenceMatrixSubset %>% apply(1,sum) %>% order(decreasing = FALSE),
                            coOccurenceMatrixSubset %>% apply(2,sum) %>% order(decreasing = TRUE)]

coOccurenceMatrixSubset = coOccurenceMatrixSubset/(sum(coOccurenceMatrix))* 100


classSums = coOccurenceMatrixSubset %>% apply(2,sum)
raceSums = coOccurenceMatrixSubset %>% apply(1,sum)

coOccurenceMatrixSubset = cbind(coOccurenceMatrixSubset,raceSums)


coOccurenceMatrixSubset = rbind(Total = c(classSums,NA), coOccurenceMatrixSubset)
colnames(coOccurenceMatrixSubset)[ncol(coOccurenceMatrixSubset)] = "Total"

coOccurenceFrame = coOccurenceMatrixSubset %>% melt() 
names(coOccurenceFrame)[1:2] = c('Race','Class')

coOccurenceFrame %<>% mutate(fillCol = value*(Race!='Total' & Class!='Total'))

coOccurenceFrame %>% ggplot(aes(x = Class,y = Race)) +
    geom_tile(aes(fill = fillCol),show.legend = FALSE)+
    scale_fill_continuous(low = 'white',high = '#46A948',na.value = 'white')+
    # viridis::scale_fill_viridis() + 
    geom_text(aes(label = value %>% round(2) %>% format(nsmall=2))) + 
    scale_x_discrete(position='top') + xlab('') + ylab('') + 
    theme(axis.text.x = element_text(angle = 30,vjust = 0.5,hjust = 0))

```

Despite the methodoligal differences, these results seem to match with FiveThirtyEight data. Graph below shows the % occurence of a class/race combination in FiveThityEight data and my data.


```{r fiveThirtyEightCorr,message=FALSE,fig.height=3.5,fig.width=3.5}
fiveThirtyEight = read_tsv('538.tsv') %>% melt()
names(fiveThirtyEight)[2] = 'Class'

fiveThirtyEight %<>% mutate(Class = as.character(Class)) %>%
    arrange(Race,Class) %>% filter(Race !='TOTAL' & Class != 'TOTAL')

coOccurenceFrame %<>% mutate(Race = toupper(Race), Class = toupper(Class)) %>% 
    arrange(Race,Class) %>% 
    filter(Race %in% fiveThirtyEight$Race & Class %in% fiveThirtyEight$Class)

corFrame = data.frame(FiveThirtyEight = fiveThirtyEight$value/1000, oganm = coOccurenceFrame$value,
           class = coOccurenceFrame$Class,race = coOccurenceFrame$Race)

corFrame %>% ggplot(aes(x = oganm,y = FiveThirtyEight,text = paste(class, race))) + geom_point()
```

## Is your character archetype rare?

```{r}
# uniqueTable$justClass


```

## Is your feat choice rare?

Jeremy Crawford once [tweeted](https://twitter.com/jeremyecrawford/status/969020122177331200?lang=en)

> Another piece of D&D data: a majority of D&D characters don't use feats. Many players love the customization possible with feats, but a larger group of players is happy to make characters without feats. Feats are, therefore, not a driving force behind many players' choices. 

We can see weather or not our data agrees. On a surface look `r round(sum(!is.na(uniqueTable$feats))/nrow(uniqueTable)*100)`% of all characters
have at least one feat. However this is partially caused by  the fact that a significant portion (`r round(sum(uniqueTable$level == 1)/nrow(uniqueTable)*100)`%) 
of our characters are level 1. We can see that by higher levels, feat adoption rates increase significantly, suggesting that once given the opportunity, players are likely to pick a feat.


```{r featProportions,fig.height=4}
uniqueTable %>% 
    filter(!is.na(levelGroup)) %>% 
    group_by(levelGroup) %>% 
    mutate(levelGroup2 = paste0(levelGroup,'\n(',n(),' chars)')) %>% 
    ungroup() %>% 
    arrange(levelGroup) %>% 
    mutate(levelGroup2 = factor(levelGroup2, levels = unique(levelGroup2))) %>% 
    group_by(levelGroup2) %>% 
    summarise(featPopularity = sum(!is.na(feats))/n()*100) %>%
    ggplot(aes(x = levelGroup2,y = featPopularity)) +
    geom_point() +
    ylab('% with at least one feat') + xlab('Level Interval')

```

It can be postulated players spend most of their time between levels 4-15. `r uniqueTable %>% filter(as.integer(levelGroup) %in% c(2,3,4)) %>% {round(sum(!is.na(.$feats))/nrow(.)*100)}`% of all characters
in this range has at least one feat. 



```{r}
class = singleClassed$justClass
feats = singleClassed$feats

uniqueFeats = feats %>% str_split('\\|') %>% unlist %>% unique %>% na.omit()

# singleClassed %>% filter(!is.na(feats))

```




## Is your multiclass combination rare?

Since our dataset includes multiclassed characters, we can see which classed tend to appear
together. Note that our sample size much smaller here (`r nrow(multiClassed)` characters). Node sizes in the 
network below show how many times a class appeared in all multiclassed characters. The thickness of the lines between the nodes
are determined by the number of characters both classes appear in. For instance we see that most rangers
multiclass with rogues, while most rogues multiclass with fighters.

```{r multiClassingNetwork}

coOccurence = multiClassed$justClass
# in case I need them ordered
uniqueClasses =   coOccurence %>% strsplit('\\|') %>% unlist %>% table %>% sort(decreasing = TRUE) %>% names
uniqueClasses = uniqueClasses[!uniqueClasses %in% 'Artificer']
adjMatrix = matrix(0,nrow= length(uniqueClasses),ncol = length(uniqueClasses))

for (i in seq_along(uniqueClasses)){
    for(j in seq_along(uniqueClasses)){
        if(i !=j){
            adjMatrix[i,j] = sum(grepl(x = coOccurence,pattern = uniqueClasses[i]) &  grepl(x = coOccurence,pattern = uniqueClasses[j]))
        }
    }
}
rownames(adjMatrix) = uniqueClasses
colnames(adjMatrix) = uniqueClasses
network=graph_from_adjacency_matrix( adjMatrix, weighted=T, mode="undirected", diag=F)
E(network)$width <- E(network)$weight

maxWeight = E(network)$weight %>% max
maxStrength = strength(network) %>% max
par(mar=c(0,0,1,0))

plot(network,layout = layout_in_circle,
     vertex.frame.color="white",
     vertex.label.color="black",
     vertex.size = strength(network),
     main = 'Multiclassing network',
     asp = 1
     )


```


While this network is good to show which classes tend to be chosen together, it doesn't
give much information about how classes are distributed. In the below graph we look at
what is ratio of class levels in individual characters. A Fighter 5/Rogue 15 would appear
as a 25% data point in the Fighter column and 75% in the Rogue column.

```{r multiClassingProportions}

multiClassProportion = lapply(uniqueClasses, function(x){
    classSubset = multiClassed %>% filter(grepl(x,justClass))
    
    classLevel = classSubset$class %>% str_extract(glue('{x} [0-9]+')) %>% str_extract('[0-9]+') %>% as.integer
    
    classLevel/classSubset$level
    
})

multiClassTotalLevel =  lapply(uniqueClasses, function(x){
    classSubset = multiClassed %>% filter(grepl(x,justClass))
    totalLevel = classSubset$level

})

names(multiClassProportion) = uniqueClasses
names(multiClassTotalLevel) = uniqueClasses

multiClassProportion %<>% melt
order = multiClassProportion %>% group_by(L1) %>% summarise(mean = mean(value)) %>% arrange(desc(mean)) %$% L1

multiClassProportion$L1 %<>% factor(levels = order)
multiClassTotalLevel %<>% melt

multiClassProportion = cbind(multiClassProportion,multiClassTotalLevel$value)

names(multiClassProportion) = c('ClassProp','Class','Level')

multiClassProportion %>%
    ggplot(aes(x = Class, y = ClassProp*100)) + geom_violin(color = "#C4C4C4", fill = "#C4C4C4") +
    geom_jitter(alpha = .5,width = 0.1) +
    theme(axis.text.x = element_text(angle = 90,vjust = 0.5,hjust = 1 )) + 
    ylab('% of character level') +
    xlab('') 

```

While there is a high amount of variation in the data, some conventional wisdom 
pops up through the means. Warlock is famous for its dipping potential and a Cleric
level synergizes nicely with many other class features. I am a proud owner of a Cleric
dipped Fighter myself. I would avoid reading too much into this though. The variance
is too high and sample size is too low to make reliable inferences.




```{r multiClassingAndFeats}
highLevel = uniqueTable %>% filter(levelGroup %>% as.integer %>% {.>1})
HLmultiClassed = highLevel %>% filter(grepl('\\|',justClass))
HLsingleClassed = highLevel %>% filter(!grepl('\\|',justClass))

singleClassedFeaters = sum(!is.na(HLsingleClassed$feats))

multiClassedFeaters = sum(!is.na(HLmultiClassed$feats))
pVal = phyper(multiClassedFeaters,
              multiClassedFeaters + singleClassedFeaters,
              sum(is.na(uniqueTable$feats)),
              nrow(multiClassed), lower.tail = FALSE, log.p = FALSE)
```
Both multiclassing and picking feats are somewhat advanced character building rules.
While making the character building process complicated, they can be used to create frighteningly 
affective combinations (or get stuck waiting till the end of the campaign till their build gets
everyting they want). Intuitively, it wouldn't be surprising to see that multiclassers are more likely
to get feats to optimize their builds. Indeed, we see that `r round(multiClassedFeaters/nrow(HLmultiClassed)*100)`% 
of  multiclassed characters above level 3 chose to get a feat as opposed to 
`r round(singleClassedFeaters/nrow(HLsingleClassed)*100)`% of single classed counterparts.
A modest yet statistically significant difference.


## Is your game day rare?

My applications are they are purely utilitarian. One gives you
a character sheet, the other is an interactive character sheet that automates your dice roll.
It is reasonable to think that most people would be using them before or during a game. Graphs below
how many characters were created in each day of the week and below that there's a punch card that 
shows individual hours. 

Frankly not much to be said here. Most popular days of the week are obviously weekends,
hours of day are somewhat unreliable as I didn't correct for user timezones. US alone,  which seems to be 
where most my users are coming from , can
have 3 hours of difference. I could use IPs and detect locations to fix times but not 
going into that rabbit hole...

```{r gameDay,fig.height=8}
reliableDateTable = uniqueTable %>% filter(as.Date(date) >  as.Date('2018-04-16'))

days = reliableDateTable$ date %>% weekdays()
hours = as.POSIXlt( reliableDateTable$date)$hour

time = data.frame(days = factor(days, levels = c('Monday','Tuesday','Wednesday','Thursday','Friday','Saturday','Sunday')), hours = hours)


time %>% group_by(days,hours) %>% summarise(users = n()) %>%
    ggplot(aes(x = days,y = hours,size = users)) + geom_point() +
    theme(axis.text.x = element_text(angle = 90,vjust = 0.5,hjust = 1 )) +
    xlab('') +
    ylab('Hour of Day') -> plot1

time %>% group_by(days) %>% summarise(users = n()) %>% 
    ggplot(aes(x = days,y = users)) + geom_bar(stat ='identity') + 
    theme(axis.text.x = element_blank(),
          axis.ticks.x = element_blank()) +
    xlab('') -> plot2

plot2/plot1 + plot_layout(ncol = 1, heights = c(2,5))

```

## About the data

Unique characters are aquired by grouping the characters that share the same name and class
and picking the higher level version. If a multiclassed character shares name with a single
classed character, I assume they are duplicates if the single classed character is lower level and
its class matches with one of the classes of the multiclassed character. Any character above
level 20 (there were `r sum(charTable$level > 20)`) was removed. `r sum(grepl('Revised',keepRevised$class,ignore.case = TRUE))` Revised Rangers were merged back into
the ranger class. Most percentages are rounded to the nearest integer

As all data, this data comes with caveats. It is a subset of all DnD players who are using a
particular mobile application who also know about and use my applications and consented
to let me to keep their character sheets. I don't have reason
to think that these would be enriching certain character building choices but it's
something to keep in mind.

I do believe however it is likely to have less test characters
than DnDBeyond because my tools require a pre-existing character created in a different tool.
Even if a user wants to just test it out they are likely to have a pre-existing character.
This is of course my humble opinion (in fact 2 characters in my corpus are named "Test").
